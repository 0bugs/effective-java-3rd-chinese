## ✏️ CS-Notes-PDF

- [CS-Notes-PDF](https://github.com/sjsdfg/CS-Notes-PDF) 

## 📚 高效 Java 第三版

- [01. 考虑使用静态工厂方法替代构造方法.md](notes/01.%20考虑使用静态工厂方法替代构造方法.md)
- [02. 当构造方法参数过多时使用builder模式.md](notes/02.%20当构造方法参数过多时使用builder模式.md)
- [03. 使用私有构造方法或枚类实现Singleton属性.md](notes/03.%20使用私有构造方法或枚类实现Singleton属性.md)
- [04. 使用私有构造方法执行非实例化.md](notes/04.%20使用私有构造方法执行非实例化.md)
- [05. 使用依赖注入取代硬连接资源(hardwiring resources).md](notes/05.%20使用依赖注入取代硬连接资源(hardwiring%20resources).md)
- [06. 避免创建不必要的对象.md](notes/06.%20避免创建不必要的对象.md)
- [07. 消除过期的对象引用.md](notes/07.%20消除过期的对象引用.md)
- [08. 避免使用Finalizer和Cleaner机制.md](notes/08.%20避免使用Finalizer和Cleaner机制.md)
- [09. 使用try-with-resources语句替代try-finally语句.md](notes/09.%20使用try-with-resources语句替代try-finally语句.md)
- [10. 重写equals方法时遵守通用约定.md](notes/10.%20重写equals方法时遵守通用约定.md)
- [11. 重写equals方法时同时也要重写hashcode方法.md](notes/11.%20重写equals方法时同时也要重写hashcode方法.md)
- [12. 始终重写 toString 方法.md](notes/12.%20始终重写%20toString%20方法.md)
- [13. 谨慎地重写 clone 方法.md](notes/13.%20谨慎地重写%20clone%20方法.md)
- [14. 考虑实现Comparable接口.md](notes/14.%20考虑实现Comparable接口.md)
- [15. 使类和成员的可访问性最小化.md](notes/15.%20使类和成员的可访问性最小化.md)
- [16. 在公共类中使用访问方法而不是公共属性.md](notes/16.%20在公共类中使用访问方法而不是公共属性.md)
- [17. 最小化可变性.md](notes/17.%20最小化可变性.md)
- [18. 组合优于继承.md](notes/18.%20组合优于继承.md)
- [19. 如使用继承则设计，应当文档说明，否则不该使用.md](notes/19.%20如使用继承则设计，应当文档说明，否则不该使用.md)
- [20. 接口优于抽象类.md](notes/20.%20接口优于抽象类.md)
- [21. 为后代设计接口.md](notes/21.%20为后代设计接口.md)
- [22. 接口仅用来定义类型.md](notes/22.%20接口仅用来定义类型.md)
- [23. 优先使用类层次而不是标签类.md](notes/23.%20优先使用类层次而不是标签类.md)
- [24. 优先考虑静态成员类.md](notes/24.%20优先考虑静态成员类.md)
- [25. 将源文件限制为单个顶级类.md](notes/25.%20将源文件限制为单个顶级类.md)
- [26. 不要使用原始类型.md](notes/26.%20不要使用原始类型.md)
- [27. 消除非检查警告.md](notes/27.%20消除非检查警告.md)
- [28. 列表优于数组.md](notes/28.%20列表优于数组.md)
- [29. 优先考虑泛型.md](notes/29.%20优先考虑泛型.md)
- [30. 优先使用泛型方法.md](notes/30.%20优先使用泛型方法.md)
- [31. 使用限定通配符来增加API的灵活性.md](notes/31.%20使用限定通配符来增加API的灵活性.md)
- [32. 合理地结合泛型和可变参数.md](notes/32.%20合理地结合泛型和可变参数.md)
- [33. 优先考虑类型安全的异构容器.md](notes/33.%20优先考虑类型安全的异构容器.md)
- [34. 使用枚举类型替代整型常量.md](notes/34.%20使用枚举类型替代整型常量.md)
- [35. 使用实例属性替代序数.md](notes/35.%20使用实例属性替代序数.md)
- [36. 使用EnumSet替代位属性.md](notes/36.%20使用EnumSet替代位属性.md)
- [37. 使用EnumMap替代序数索引.md](notes/37.%20使用EnumMap替代序数索引.md)
- [38. 使用接口模拟可扩展的枚举.md](notes/38.%20使用接口模拟可扩展的枚举.md)
- [39. 注解优于命名模式.md](notes/39.%20注解优于命名模式.md)
- [40. 始终使用Override注解.md](notes/40.%20始终使用Override注解.md)
- [41. 使用标记接口定义类型.md](notes/41.%20使用标记接口定义类型.md)
- [42. lambda表达式优于匿名类.md](notes/42.%20lambda表达式优于匿名类.md)
- [43. 方法引用优于lambda表达式.md](notes/43.%20方法引用优于lambda表达式.md)
- [44. 优先使用标准的函数式接口.md](notes/44.%20优先使用标准的函数式接口.md)
- [45. 明智审慎地使用Stream.md](notes/45.%20明智审慎地使用Stream.md)
- [46. 优先考虑流中无副作用的函数.md](notes/46.%20优先考虑流中无副作用的函数.md)
- [47. 优先使用Collection而不是Stream来作为方法的返回类型.md](notes/47.%20优先使用Collection而不是Stream来作为方法的返回类型.md)
- [48. 谨慎使用流并行.md](notes/48.%20谨慎使用流并行.md)
- [49. 检查参数有效性.md](notes/49.%20检查参数有效性.md)
- [50. 必要时进行防御性拷贝.md](notes/50.%20必要时进行防御性拷贝.md)
- [51. 仔细设计方法签名.md](notes/51.%20仔细设计方法签名.md)
- [52. 明智审慎地使用重载.md](notes/52.%20明智审慎地使用重载.md)
- [53. 明智审慎地使用可变参数.md](notes/53.%20明智审慎地使用可变参数.md)
- [54. 返回空的数组或集合，不要返回 null.md](notes/54.%20返回空的数组或集合，不要返回%20null.md)
- [55. 明智审慎地返回 Optional.md](notes/55.%20明智审慎地返回%20Optional.md)
- [56. 为所有已公开的 API 元素编写文档注释.md](notes/56.%20为所有已公开的%20API%20元素编写文档注释.md)
- [57. 最小化局部变量的作用域.md](notes/57.%20最小化局部变量的作用域.md)
- [58. for-each 循环优于传统 for 循环.md](notes/58.%20for-each%20循环优于传统%20for%20循环.md)
- [59. 了解并使用库.md](notes/59.%20了解并使用库.md)
- [60. 若需要精确答案就应避免使用 float 和 double 类型.md](notes/60.%20若需要精确答案就应避免使用%20float%20和%20double%20类型.md)
- [61. 基本数据类型优于包装类.md](notes/61.%20基本数据类型优于包装类.md)
- [62. 当使用其他类型更合适时应避免使用字符串.md](notes/62.%20当使用其他类型更合适时应避免使用字符串.md)
- [63. 当心字符串连接引起的性能问题.md](notes/63.%20当心字符串连接引起的性能问题.md)
- [64. 通过接口引用对象.md](notes/64.%20通过接口引用对象.md)
- [65. 接口优于反射.md](notes/65.%20接口优于反射.md)
- [66. 明智审慎地本地方法.md](notes/66.%20明智审慎地本地方法.md)
- [67. 明智审慎地进行优化.md](notes/67.%20明智审慎地进行优化.md)
- [68. 遵守被广泛认可的命名约定.md](notes/68.%20遵守被广泛认可的命名约定.md)
- [69. 只针对异常的情况下才使用异常.md](notes/69.%20只针对异常的情况下才使用异常.md)
- [70. 对可恢复的情况使用受检异常，对编程错误使用运行时异常.md](notes/70.%20对可恢复的情况使用受检异常，对编程错误使用运行时异常.md)
- [71. 避免不必要的使用受检异常.md](notes/71.%20避免不必要的使用受检异常.md)
- [72. 优先使用标准的异常.md](notes/72.%20优先使用标准的异常.md)
- [73. 抛出与抽象对应的异常.md](notes/73.%20抛出与抽象对应的异常.md)
- [74. 每个方法抛出的异常都需要创建文档.md](notes/74.%20每个方法抛出的异常都需要创建文档.md)
- [75. 在细节消息中包含失败一捕获信息.md](notes/75.%20在细节消息中包含失败一捕获信息.md)
- [76. 保持失败原子性.md](notes/76.%20保持失败原子性.md)
- [77. 不要忽略异常.md](notes/77.%20不要忽略异常.md)
- [78. 同步访问共享的可变数据.md](notes/78.%20同步访问共享的可变数据.md)
- [79. 避免过度同步.md](notes/79.%20避免过度同步.md)
- [80. executor 、task 和 stream 优先于线程.md](notes/80.%20executor%20、task%20和%20stream%20优先于线程.md)
- [81. 相比 wait 和 notify 优先使用并发工具.md](notes/81.%20相比%20wait%20和%20notify%20优先使用并发工具.md)
- [82. 文档应包含线程安全属性.md](notes/82.%20文档应包含线程安全属性.md)
- [83. 明智审慎的使用延迟初始化.md](notes/83.%20明智审慎的使用延迟初始化.md)
- [84. 不要依赖线程调度器.md](notes/84.%20不要依赖线程调度器.md)
- [85. 优先选择 Java 序列化的替代方案.md](notes/85.%20优先选择%20Java%20序列化的替代方案.md)
- [86. 非常谨慎地实现 Serializable.md](notes/86.%20非常谨慎地实现%20Serializable.md)
- [87. 考虑使用自定义的序列化形式.md](notes/87.%20考虑使用自定义的序列化形式.md)
- [88. 保护性的编写 readObject 方法.md](notes/88.%20保护性的编写%20readObject%20方法.md)
- [89. 对于实例控制，枚举类型优于 readResolve.md](notes/89.%20对于实例控制，枚举类型优于%20readResolve.md)
- [90. 考虑用序列化代理代替序列化实例.md](notes/90.%20考虑用序列化代理代替序列化实例.md)